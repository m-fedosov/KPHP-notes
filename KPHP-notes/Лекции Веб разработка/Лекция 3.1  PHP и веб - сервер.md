> Я очень обрадовался найдя эту [статью](https://alexp007.ru/blog/kak-php-vzaimodeystvuet-s-serverom/?ysclid=lcjad67tf6429092165) и [эта](http://xandeadx.ru/blog/php/866) тоже неплохая

PHP не работает сам по себе. Для работы с пользователем он должен быть настроен в связке с веб-сервером, например, Nginx или Apache. Если по-простому, то пользователь отправляет запрос к веб-серверу по протоколу HTTP. Веб-сервер определяет, к какому типу файла было совершено обращение, и, если это файл с расширением .php, то веб-сервер передаёт запрос на обработку интерпретатором языка PHP, скрипт считывается, преобразуется в байт-код, выполняется и возвращает ответ веб-серверу. Веб-сервер передаёт сформированный результат пользователю. Этот результат, как правило, представляет собой динамически сгенерированную HTML-страничку.
![[Pasted image 20230105190049.png]]

*При изучении php вопрос коммуникации интерпретатора и сервера часто рассматривается поверхностно или в принципе выносится за рамки, однако это знания необходимо*

**Sapi** - это **_способ взаимодействия_** между программой веб-сервером и php-интерпретатором.

**SAPI (Server Application Programming Interface)** — программный интерфейс, который предназначен для встраивания интерпретатора PHP в другие приложения и отвечает за его работу (запуск, остановка, передача скриптов на исполнение, доступ к внешним данным). В частности, SAPI позволяет интерпретатору PHP работать в качестве части web-приложения (а по сути — как часть веб-сервера), получать конкретные запросы от программы-сервера и отдавать данные.

### Динамический контент

Изначально веб-серверы работали только со статическим контентом, отдавали html-страницы, jpeg картинки и прочее. Однако, с развитием интернета появилась необходимость работать с динамическим контентом(создаваемым на лету). Динамика обогащает пользовательский опыт и превращает простые сайты в настоящие веб-сервисы. Тут на сцену и выходит php вместе с cgi.

### Какие бывают SAPI

Существует несколько основных SAPI, определяющих способы запуска и использования PHP:

- CGI
- fastCGI
- php-fpm
- mod_php
- php-cli (>= php 5.4.0), *правильно кли, а не сиэлай :))*

Если вы используете хостинг или машину настраивали не вы, может потребуется время, чтобы узнать какой режим взаимодействия сервера и php используется. Самый быстрый способ это изучить [phpinfo](https://www.php.net/manual/en/function.phpinfo.php) или распечатать значение константы [PHP_SAPI](https://www.php.net/manual/en/function.php-sapi-name.php)
```php
php_sapi_name(): string|false
```

## Common Gateway Interface (CGI)
Интерфейс описывающий взаимодействие между сервером и программой(скриптом). Каждый раз, когда приходит запрос на исполнение соответствующего скрипта, сервер поднимает дополнительный процесс, который запускает интерпретатор php и полученный результат возвращает клиенту. По сути дела интерпретатор запускается в режиме cli (STDIN/STDOUT). Схему можно представить так:

![[Pasted image 20230105192224.png]]
![[Pasted image 20230105193550.png]]

Запрос от клиента поступает на сервер, если запрашиваемый документ статический и находится на сервере, то сервер просто отдает его. Если же документ(тип документа) является динамическим, то будет поднят новый процесс, который через интерфейс CGI запустит php-скрипт, а результат его работы вернет клиенту.

Программист разрабатывающий cgi-скрипты должен позаботится об ответе состоящим из заголовков и тела в соответствии с протоколом http. Например, для простого сценария, возвращающего html, обязательно должен быть установлен Content-type.

**Пример cgi-программы:**
```php
#!/usr/bin/php
<?php

echo "Content-type: text/html; charset=utf-8\n\n"
echo '<h1>Привет МИР!</h1>';
```

Обратите внимание на первую строчку **#!/usr/bin/php** - это указание веб-серверу на интерпретатор php, который необходимо вызвать, чтобы исполнить код.

**Итог по CGI**
- Создает новый процесс на каждый входящий http запрос
- На каждый запрос читает конфиг php.ini, подгружает php расширения, читает необходимые php файлы *(с PHP 5.5 есть OPCache, но есть нюансы - например, при обновлении скриптов старый кэш почти невозможно использовать)*
- Потребляет много памяти
- Данные передаются через env и стандартные потоки ввода/вывода

### Переменные среды CGI
![[Pasted image 20230105194319.png]]


## fastCGI – зачем?
fastcgi - это технология обработки запроса, по которой каждый воркер крутится в бесконечном цикле, обрабатывая в каждой своей итерации по одному запросу.
![[Pasted image 20230105195553.png]]
![[Pasted image 20230105195136.png]]

- **Исправление фатального недостатка CGI** - переиспользование процессов (с помощью пула). Ну это просто глупость при каждом запросе поднимать новый процесс
- Использует unix socket или адрес хоста вместо стандартных потоков ввода/вывода

	Сокеты Unix — это форма связи между двумя процессами, которая отображается в виде файла на диске. Этот файл может использоваться другими программами для установления очень быстрых соединений между двумя или более процессами без каких-либо сетевых накладных расходов.
	
	Сокеты — это прямая связь между двумя процессами. Представьте, что вы хотите позвонить своему другу по дороге; вы можете сделать звонок, направив его через вашу телефонную компанию и обратно в их дом, или вы можете провести провод прямо в их дом и исключить посредника. Последнее, очевидно, непрактично в реальной жизни, но в мире Unix очень распространено устанавливать эти прямые связи между программами.

Что ещё можно сделать лучше в FastCGI?

## PHP-FPM (FastCGI Process Manager)
Альтернативная реализация fastCGI написанная в Badoo. Одно из главных улучшений - более продвинутая работа с процессами(static/dynamic/ondemand). Количество запущенных воркеров зависит от нагрузнки на сервер. Можно установить максимальное и минамальное количество процессов, которое будет меняться динамически в предложенном диапозоне.

**PHP-FPM — это:**
-   продвинутое управление процессами с корректной процедурой остановки и запуска;
-   возможность запуска воркеров с различными окружением (uid, gid, chroot);
-   возможность запуска воркеров на различных портах с использованием разных конфигураций php.ini;
-   логирование стандартных потоков вывода (stdout) и ошибок (stderr);
-   аварийный перезапуск в случае внезапного разрушения opcode-кэша;
-   поддержка ускоренной загрузки (accelerated upload);
-   логирование медленно выполняющихся скриптов (включая трассировки);
-   динамическое или статическое порождение дочерних процессов;
-   доступность базовой информации о статусе SAPI (аналогично Apache mod_status);
-   конфигурация php-fpm.conf основана на стандартном синтаксисе php.ini.

>Наиболее часто используется связка [nginx](https://web-creator.ru/articles/accelerate_site_nginx) и PHP-FPM, которая работает эффективнее «классического» использования [Apache](https://web-creator.ru/articles/httpd) с mod_php, а в ряде случаев показывает более высокую производительность

## Apache mod_php
Это модуль для Apache, позволяющий ему выполнять php скрипты. Является наверно самым популярным и простым способом подружить Apache и PHP. Модуль не использует ни CGI, ни FastCGI. Есть свои минусы — скрипты работают под пользователем веб-сервера, невозможно использовать больше одной версии PHP.

- Модуль для apache
- Не нужен ни cgi, ни fcgi, код интерпретируется самим сервером
- Конфиги и расширения подгружаются единоразово, при старте 
- Не имеет накладных расходов на передачу данных 
- Работает на тех же процессах, что раздают статику

![[Pasted image 20230106144541.png]]

## php-cli
- Всё запускается в один процесс
- Удобно для локальной разработки
- В остальных случаях лучше не использовать :)

Варианты запуска:
```php
php -S $host:$port index.php
php -S $host:$port -t $root_dir_path
php -S $host:$port
```

## Другие варианты
Java сервлеты и контейнеры сервлетов (Jetty, JBoss, IBM WebSphere)
Всё более менее похоже:
1. Нужно описать конфиг
2. Нужно скомпилировать файл Java
3. Подсовываем серврелет контейнеру файл и конфиги 
4. И всё происходит почти также ))

### Что-то современное
“Embedded” сервера: userver (c++), one-nio (java)

## Самое быстрое
Различные io-библиотеки: libevent(c++), netty (java)