![[Pasted image 20221228170937.png]]

Это простое представление того, как память программы представлена в системе.

Размер стека по умолчанию - порядко 10 мб (его конечно можно увеличить, но если так сделать, то программу будет сложно переносить на другие системы)

Под кучу выделяется **всё** остальное свободное место. Допустим мы захотели запустить майнкрафт С edition на ПК, где есть всего 2 гб оперативы. Что делать? Памяти мало, а играть хочется (( Не беда, для таких случаев разработчик должен предусмотреть, чтобы при недостатке оперативки переменные сохранились в "медленную" память на жёстком диске. 
*В майн будем гонять в 2 fps, за то сможем поиграть :)*


Такс, память - это на самом деле сложно, пока мы ещё зелёные. Так что давайте разберём простой пример:

## Как растёт стек

Понятно, что всё локальные переменные и параметры программы хранятся в данном примере в стеке:
```c
int sum(int a, int b) {
	int s = a + b;
	return s;
}
int main() {
	int c = 1; int d = 2;
	int e = sum(c, d);
	return 0;
}
```

Но как именно? Сначала у нас идёт функция main, создаётся кадр main, там у нас будут переменные c, d, e. В main вызывается функция sum, значит нужно создать кадр для sum, ну что, звучит довольно просто.
![[Pasted image 20221228172138.png]]
А что за RV и RA. Хороший вопрос. Если ты заметил, то так-то функциях есть `return` с укаанным значением. А где мы будем хранить это самое значение, в RV )) 
- RV — return value (возвращаемое значение). Занимает то кол-во байт, сколько соответствует типу возвращаемого значения.

На а что такое RA? Вспоминаем [[Лекция 3.1 Указатели на функции]] Каждая функция, так-то тоже представлена в памяти как адрес. Какую инструкцию нужно дать процессору после завершения функции  sum - вернуться к функции main
- RA — return address (адрес инструкции, куда необходимо передать управление по завершении данной функции). Всегда занимает столько байт, сколько использует архитектура для адресации. В современных архитектурах у нас же больше 4гб оперативки, а значит один адрес занимает 64 бита = 8 байт.

Вот как это всё будет работать:
![[Pasted image 20221228173300.png]]

## Как процессор понимает где какой кадр
Кадр - удобная абстракция для человека, но для компьютера она не нужна. У процессора есть **SP регистр**, который хранит в себе адрес начала кадра

Например, создан кадр функции main, sp = 600
Создан кадр sum, sp = 600 - 24 = 576 (стек растёт вниз, нам так просто удобно)
Кадр sum отработал, sp = 600


## Почему рекурсия это плохо
Поскольку программы по умполчанию работают со стеком, а область памяти у стека совсем маленькая. Часто возникают ошибки переполнения стека - stack overflow :D 

Легче всего этого достичь при рекурсии, нужно просто при каждом вызове программы снова занимать новую область памяти для локальной переменной, вот как тут:
```c
int factorial(int n) {
	if (n == 1)
		return 1;
	else
		return factorial(n-1) * n;
}
```

Просто напиши for, не позорься, а то руки ещё сломают ))
```c
#include <stdio.h>
int main () 
{
	for (int n = 1; n <= 100; n ++){
		float ans = 1;
		for (int i = 2; i <= n; i++){
			ans = ans * i;
		}
		printf("%d! = %f\n",n ,ans);
	}
	return 0;
}
```
