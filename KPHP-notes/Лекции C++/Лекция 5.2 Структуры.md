Окей, это простая штука
Ключевое слово `struct` отвечает за создание структуры. Сама структура - это последовательно записаные переменные:

```c
struct product_s { // всего занимает 9 байт
	char label[256]; // 1 байт
	float weight; // 4 байта
	unsigned int price; // 4 байта
};
```

Как работать со структурой? 

- Можем создать один экзмепляр структуры
```c
struct product_s p1;
// Записываем значения по указателю
scanf("%s %f %d", p1.label, &(p1.weight), &(p1.price));

// Или сразу инициализируем
struct product_s p2 = { "Milk", 100, 5 };
```

- Можем сразу несколько
```c
struct product_s array[100];
array[0].weight = 42;
```

- Можем создать указатель и работать с его значениями как со структурой:
```c
struct product_s* ptr = malloc(sizeof(struct product_s));
ptr->weight = 42; // прибавляем к значению указателя 1 байт и записываем 42
```

## Копиравание
```c
struct product_s a, b;
scanf("%s%f%d", a.label, &a.weight, &a.price);
b = a; // Полностью копирует побайтово все поля, даже массивы.
a.price += 10;
printf("%d %d\n", a.price, b.price); // Разные значения.
```

- Оператор `=` требует линейное время.
- **Тонкость:** если в структуре есть указатель, то будет скопировано только значение указателя, а не данные, на который он указывает.
```c
struct array_s {
	int* p; // указатель
	int n;
};
struct array_s a, b;
a.p = malloc(sizeof(int) * 100); // задаём a.p адрес
a.n = 100;
b = a; // адрес указателя a.p скопирован в указатель b.p
a.p[0] = 42;
printf("%d %d", a.p[0], b.p[0]); // Одинаковые значения - ссылаются на одно и тоже место в памяти
```

В C/C++ структуру можно разместить где угодно - на стеке, в глобальной памяти, на куче (malloc).

```c
struct product_s p1;
struct product_s p2;
// p1 и p2 независимы, скопировать все поля из p1 в p2
p2 = p1;
// p3 и p4 содержат адрес одной и той же области памяти со структурой
struct product_s* p3 = malloc(sizeof(struct product_s));
struct product_s* p4 = p3;
```

## Как менять значения структур через функции

**На стеке:**
```c
struct product_t create_expensive(struct product_t prod) { // создал 3ю структуру
	prod.price *= 2;
	return prod; // вернул созданную структуру
}

int main() {
	struct product_t p, expensive_p; // разметил 2 струкртуры на стеке
	expensive_p = create_expensive(p);  // скопировал в expensive_p prod
}
```

Надо скопирвать на стек `sizeof(product_t)` байт для параметра функции и столько же для возвращаемого значения.

Это может быть долго. Поэтому, если функции по смыслу не требуется копия как в примере выше, лучше пользоваться указателями.

**С помощью указателей:**
```c
void rand_fill(struct product_s* ptr) { // здесь просто указатель на 8 байт
	...
	ptr->weight = ...
	...
}

int main() {
	struct product_s p;
	rand_fill(&p); // зачем?
}
```

- Указатель позволяет менять значение (для структур — значение полей) переданной переменной.

## Typedef
Что не писать ключевое слово `struct` можно воспользоватесь псевдонимом:
```c
typedef struct product_s product_t; //псевдоним
product_t p; // меньше букв, больше мемов
```

**Чем typedef лучше define?**
`typedef` - выполняется компилятором, который выяснил типы
идентификаторов перед подстановкой (typedef применится
только в типам)
`define` - выполняется препроцессором, который работает как "найти и заменить" в блокноте. Может взять, и поменять случайно имя переменной на значение define

## Немного из практики
В домашнем задании нужно сделать структуру интрузивного связного списка, вот небольшое объяснение что это за структура такая:
![[Pasted image 20230105183728.png]]