	"Write once, compile everywhere" 
	- Слоган языка С

Если быть честным, то этот слоган не совсем себя оправдывает. Программы часто зависят не только от процессора, но и от платформы на которых они исполняются. Было бы классно писать на Kotlin проги и на Android, и на ios. Но нужно учитывать, что платформа ОС предоставляет разные встроенные возможности (отличаются утилиты для gui, и т.п.) 

Как же быть?

При современном подходе к разработке, не возникает особых проблем при портировании программ на разные платформы. 

Допустим у нас есть игра Шахматы, в которой реализован:
- Графический интерфейс
- Проверка ходов, чтобы нельзя было обмануть игру
- Бот, соперник

Функционал вполне себе разделяется на разные файлы, так по многим причинам гораздо удобнее:
- Легче разделять задачи по разработке
- Код становится более читаемым
- Можно переиспользовать файлы проектов
- Легче работать с системой контроля версий

Ну и просто прикинь насколько это неудобно читать прогу, когда она вся написана в одном файле

***Но более того, это решает очень важную проблему:***
для переноса программы с Android на ios достаточно переписать файл графического интерфейса, который теперь будет использовать встроенные средства разработки ios. Ведь, бот и проверка ходов - уже относится к логике программы, и скорее всего никак не завязаны на платформу реализации.

## Теперь убедившись, что жестоко разделывать прогу на части - круто. Узнаем какие трудности нам это сулит

# Компиляция файлов
При вызове компиляции файлов проекта **каждый файл** компилируется по отдельности. Компилируя шахматы, мы отдельно компилируем интерфейс, бота и проверку ходов. Программы не склеиваютя в один файл и хранятся в разных местах памяти. Приведу более простой пример:
```c
//main.c
int main() {
	int a = 3;
	int b = 5;
	int c = a + b;
	int d = sum(c, b);
	return 0
}
```

```c
//util.c
int sum(int a, int b) {
	return a + b;
}
```

Что произойдёт при компиляции?
Сначала main.c -> main.o
После util.c -> util.o

Все иструкции на языки C перегонятся компилятором в ассемблер. Что делать с инструкцией sum? Она тоже закодируется в вызов sum. 

Полученные объектные файлы будут типо таких :

```assembler
//main.o
1 300 1
1 500 2
3 1 2 3
2 3 100
call sum
```

```assembler
//sum.o
func sum
43 500 2
4 1 2 3
4 3 100
```

Вызов функции изменился на call, только как видно, мы не указываем адрес ячейки к которой нужно обратиться. А значит такая программа не сможет сделать то что мы хотим, а может и вовсе не запуститься :)

Нам нужен
# Линковщик
Это программа которая проходится по объектным файлам, ищет в них вызовы функций и заменяет их на адрес ячейки куда нужно обратиться за этой самой функцией. 

main.o, util.o -> main.elf

посмотрим на файл main.elf, укажем рядом с инструкцией адрес ячейки каждой инструкции. (пусть в нашем случае размер регистра 4 байта)

```assembler
//main.elf
[20] 1 300 1
[24] 1 500 2
[28] 3 1 2 3
[32] 2 3 100
[34] 13 52 # call 52

...

[52] 43 500 2
[56] 4 1 2 3
[58] 4 3 100
```

Таким образом линкер склеил файлы вместе и заменил вызовы функций по имени, на вызовы по адресу

>В KPHP при комплияции kphp2cpp вызывается линковших, который склеивает весь твой код в один файл. 

## Очевидные плюсы
Даже если исполниние одного файла зависит от другого. И один из файлов мы переписываем. То для сборки проекта снова, нам достаточно скомпилировать только изменённый файл. Profit

Линковка и комплиция занимает всего в сумме два прохода по файлу, что вообще кайф как быстро

## Минусы, куда без них ))
*А как спрашивается, программа узнает, что вызов функции осуществлён правильно...*

Для функции sum нужно задать два параметра, а что если передать только один? А ничего, Ошибки не будет, только вот программа начнёт себя странно вести и считывать случайное значение для второго параметра

# Заголовочные файлы.h
Решение такого нюанса - поместить объявление функции в заголовочный файл

```c
//main.c
# include "util.h"
int main() {
	int a = 3;
	int b = 5;
	int c = a + b;
	int d = sum(c); // compilation error
	return 0;
}
```

```c
//util.c
# include "util.h" 
int sum(int a, int b) { // definition
	return a + b;
}
```

```c
//util.h
int sum(int a, int b); //declaration
```

Определение (declaration) препроцессор вставляет вместо # include "util.h". После уже компилятор увидит, что вызов sum в main.c отличается от эталонного util.h и выведет ошибку. Линковщих в таком случае не будет запускаться.

**Препроцессор** - простая программа, которая просто изменяет файл по некоторым правилам перед компиляцией

# Обработка ошибок линковки

## Undefined reference
При втором проходе (линковщих) видит вызов функции, но не нашёл её адрес в таблице. То есть функция скорее всего не определена

## Multiple definition
Обратная ошибка, когда линковщик видит сразу несколько определений функций с одинаковыми параметрами - он не понимает какую из них он должен взять. Как решение - называй нормально функции и не повторяйся.