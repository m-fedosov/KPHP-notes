Переходим к последнему типу памяти. Чем же куча (heap) отличается от всех остальных. Вспоминаем прошлые лекции:
- Куча занимает всё свободное место в оперативной памяти
![[Pasted image 20221228170937.png]]
- Удаление элементов из кучи происходит либо после остановки программы, либо их в ручную удаляет программист, прописывая это в коде программы.

Окей, какой минимальный набор [[Функции стандартной библиотеки]] нужен, чтобы работать с кучей:
- `malloc` - обращается к операционной системе с просьбой выделить место (“непрерывный кусок”) в куче и, если ОС выделяет это место, возвращает укзатель на начало области (иначе — 0).
- `free` - функция освобождает память

Пример:
```c
#include <stdlib.h>

int *p = malloc(1000000 * sizeof(int));
if (p == NULL){ // NULL в C, nullptr в C++. Старый код - 0.
	/* not enough memory */
}
// if (!p) { ... } // Альтернативный вариант
p[0] = 1; p[13000] = 42;
...
free(p);
```

## В каких случаях нужно использовать кучу

Первый очевидный случай, нам нужно хранить очень большой массив, который не помещается в стек. Зачем нам в ручную увеличивать размер стека, если проще будет воспользоваться кучей, так и программу можно будет запустить на любом устройстве и можно обрабытывать ошибки. 

> Если свободного место в куче будет недостаточно, то на указтель вернётся  значение NULL (см. пример выше)

Ну а дальше больше, у стека и глобальных переменных есть проблема - размер переменных в коде должен быть известен при компиляции. То есть если пользователь сам задаёт размер массива или он нам передаёт картинку любого размера, то нам будет удобнее всего использовать кучу, она допускает создание переменных, которые занимают разный объём памяти.

Например, размер массива выясняется во время выполнения (ввел
пользователь, считали из файла):
```c
#include <stdlib.h>
#include <stdio.h>

size_t size = 0;
// %zu вместо %d, потому что size_t может != int.
scanf("%zu", &size);
int *array = malloc(size * sizeof(int));
```


## Ошибки, или как не наложить кучу

#### Использоовать кучу для маленьких переменных
Что тут не так? 
```c
int *p = malloc(sizeof(int));
free(p);
```
Первая ошибка  - это ~~ты, вторая - все твои мечты~~ бессмысленное использование `malloc` . Программист хочет сохранить в куче переменную типа `int`. На стеке `int p` занимала бы 4 байта. В примере такая переменная занимает уже 12 байт
8 байт - указатель на переменную, который хранится в стеке
4 байта - сама переменная в куче

#### Утечка памяти
А вот это **самая-самая** ошибка, считай что из-за неё люди стали придумывать свои новые языки программирования (Java и т.п.)

```c
int *p = (int *)malloc(1000000 * sizeof(int));
p = (int *)malloc(1000000 * sizeof(int)); //чел забыл free - он позор своей семьи
// Или: p = NULL;
```

Утечка памяти (memory leak): теперь память из первой строки невозможно освободить (мы потеряли адрес). Потому что в первой строке был один адрес для указателя p, а во 2ой назначается новый, не затирая старый.

**Такие ошибки можно искать утилитой valgrind** - только работает оно долго, потому что утилита проверяет все адреса созданные в коде

Данная проблема больше всего заметна на серверах, когда они выполняют одну и ту же программу без её остановки (не освобождая память). Например код выше используется чтобы сохранять в памяти новое соединение с пользователем, чтобы отдать ему html страничку. И когда это соединение уже не нужно, оно всё равно будет держаться в памяти. Даже когда куча переполнится, программа будет хранить новые данные уже не в оперативке, а на жёстком диске. Что ещё больше её замедляет. Сначала все замедлится (файл подкачки), потом ОС аварийно завершит процесс.

## Malloc и память
*Выделение памяти в куче работает дольше, чем на стеке или в области глобальных переменных*

malloc должен:
1. Пройти по списку (одна из возможным реализаций) выделенных областей
2. Найти непрерывную область нужного размера

К тому же, операционная система обычно выделяет для malloc больше памяти чем он требует (Минамальный размер ~кб) - для этого стандартная библиотека создаёт таблицу памяти с которой и работает `malloc` и `free`

Вторая проблема, `malloc` выделяет память непрерывным куском. Т.е. если у нас осталось в двух разных местах по 50 свободных байт памяти, а malloc'у нужно 100байт, то он просто не найдёт свободную для себя область памяти - **дефрагментация памяти**


## Создание двумерных массивов в куче

**Как создать двумерный массив размером NxN:**

Для начала нужно создать массив, где каждый элемент - указатель
`N * sizeof(int*)`

Затем создаём строчки:
`N * sizeof(int);`

И в начальный массив записываем указатели на эти строчки:
`m[i] = (int *)malloc(N * sizeof(int));`

```c
//int ** - синтаксический сахар, показывает, что это указатель на указатель
int **m = (int **)malloc(N * sizeof(int*));
for (int i = 0; i < N; ++i){
	m[i] = (int *)malloc(N * sizeof(int));
}
```

*В итоге мы использовали malloc N+1 раз, помни, что выделение памяти через malloc - времязатратная операция и если в программе нужно создать **большой** массив, то лучше использовать другой алгоритм, который использует malloc только 2 раза. О нём я расскажу позже*


**Как индексировать элемент в двумерном массиве:**

Если использовать синтаксический сахар, то всё очень просто
```c
m[42][42] = 42;
```

Но на самом деле `m[i]`  - значение по адресу m+i = `*(m+i)` 

`m[i][j]` - 
взять тот адрес, прибавить к нему j и получить значение по адресу - `*(*(m+i) +j)`



**Как удалить двумерный массив из кучи:**

Нужно пройтись по всем созданным сточкам и удалить их.
Затем удалить все указатели на эти строчки:
```c
for (int i = 0; i < N; ++i){
	free(m[i]);
}
free(m);
```


## Как ещё можно работать с памятью в куче
Также существует 2 полезные библиотечные функции, о которых мы ещё не говорили:
`calloc` — выделяет память и инициализирует ее нулями (обнуляет)
`realloc` — изменяет размер уже существующего массива.

**Calloc**
Объявление:
`void *calloc(size_t nitems, size_t size)`

Параметры:
-   **nitems** − Память на сколько элементов нужно выделить
-   **size** − Размер элементов

Возвращемое значение:
Указатель на выделенную память или NULL, если не нашлось необходимое кол-во

> Кажется, что это просто malloc с обнулением памяти, но на самом деле всё куда сложнее https://overcoder.net/q/8744/разница-между-malloc-и-calloc#103312

---

**Realloc**
Объявление:
`void *realloc(void *ptr, size_t size)`

Параметры:
-   **ptr** − Указатель на память, размер которой нам нужно изменить
-   **size** − Сколько памяти в куче нужно теперь выделить 

> Функция полезна потому что она имеет доступ к таблице адресов в куче и работает быстрее чем просто копировать значения по старому указателю и переносить на новый другого размера. Например, может к уже выделенным 100 байтам, поставить дальше ещё 50 байт, если мы запросили кусок на 150 байт и там уже было свободное место