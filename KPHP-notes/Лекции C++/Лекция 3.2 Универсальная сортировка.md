Окей, давным давно, в далёкой далёкой галактике... Люди неожиданно для себя поняли: "Ёпрст, а если у нас всё дофига строго типизировано, то это что получается? Под каждый тип нужно писать свою функцию. Даже если принцип работы самих функций одинаковый..."

\- Не надо, сказал Господь, и дал людям [[Лекция 3.1 Указатели на функции]]

Окей, с остальным придётся разобраться самостоятельно. Одних указателей на функции не достаточно. Ещё нам нужно:
- Передавать в функцию "любой тип данных"
- Переставлять "любые элементы" - swap
- Сравнивать "любые элементы" - cmp

Ага, придумали слово "любой" - теперь давай мучайся ))
Что нам нужно чтобы работать с любым типом данных? Ну уметь передавать **указатель** на него и говорить **сколько** мы передаём функции элементов этого типа

## Указатель на любой тип данных
Всё очень просто: `void*` естественно для него нельзя использовать адресную арифметику - как ты сможешь узнать сдвиг насколько байт нужно делать.

## Количество элементов любого типа данных
`size_t` используем в языке С, чтобы говорить о том сколько элементов данного типа мы передаём

## Swap 
Чтобы менять любые элементы нам нужно знать адрес этих элементов и их размер, ну то есть откуда и сколько байт мы должны перегнать. Помним, что char - 1 байт (самый маленький размер)

> Логично, что отсеивать ведром рис от пшена сложно, невозможно сложно, так что в качестве манипулятора мы выбрали самый маленький из доступных.

Функция swap ничего не должна возвращать, она изменяет переданные ей данные. Передаём ей откуда и куда какого размера нужно поменять.

```c
void swap(char* l1, char* l2, size_t elem_size) {
	int i = 0;
	while(i < elem_size) {
		tmp = *l1
		*l1 = *l2
		*l2 = *l1
		l1 += 1
		l2 += 1
	}
}
```

# Cmp
Теперь сделаем универсальное сравнение. Нет, не сделаем... Вы конечно захотели, по каким параметрам сравнивать будем, опиши что-ли элемент блин. А если у тебя вообще свой объект, я как узнаю как его сравнивать? 

\- Но...

\- Пиши сам :)

\- Чёрт.... :(

Не делаем универальное сравнение, любое сравнение пусти возвращает нам число больше 1, если 1 элемент больше второго. Меньше еденицы, если наоборот. Ну и 0, как можно догадаться, если равны

Сравнение для int:
```c
int cmp_int(void* p1, void* p2) {
	int* pi1 = p1; //неявное приведение типов
	int* pi2 = p2;
	return (*pi1 - *pi2); // ну а тут вычитаем одно значение из другого
}
```

Придумал свой тип и хочешь его отсортировать? Напиши для него функцию сравнения:
```c
int cmp_product_by_weight(void* p1, void* p2){
	product_t* pp1 = p1; // делаем указатель на наш тип
	product_t* pp2 = p2;
	return((*pp1).weight - (*pp2).weight); // делаем сравнение по весу
}
```

Что же, у нас всё есть, теперь можно сортировать? ДА

## Универсальная сортировка
Передаём в функцию указатель на то, что сортировать, сколько элементов нужно отсортировать, какого размера эти элементы, какой функцией их сравнивать (адрес этой функции) - [[Лекция 3.1 Указатели на функции]]

```c
void qsort(void* array, syze_t size, size_t elem_size,
		  int (*cmp)(void* p1, void* p2))
{
	//сам алгоритм сортировки
}
```

Вот как можно отсортировать массив int -ов:
```c
int array_int[100] = {1, 2, 4, 3, ...};
qsort(array_int, 100, sizeof(array_int[0]), cmp_int);
```

Или массив со своим типом данных, только остаётся написать функцию сравнения для этого типа ))

```c
product_t array_p[20];
qsort(arrap_p, 20, sizeof(array_p[0]), cmp_product_by_weight);
```

> На этом с универсальной сортировкой пока поконченно, мда-уж теорию иногда бывает скучно изучать, хотя без конретно этой штуки жить точно тяжело

