Одномерные:
```c
int array[10]; // размер такого массива 10*sizeof(int)
int array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // в явном виде задали 10 элем.
int array[10] = {0} // а теперь все 10 элементов равны 0
int array[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // компилятор может и сам посчитать сколько у нас тут элементов
```

А теперь будет прикол. У нас же всё хранится в компьютере в виде чисел, а что если char тоже назначить число
```c
char array[] = {0, 125, 2, 3, 4, 5, 6, 7, 8, 9}
```

Тогда на месте `array[1]` при выводе я получу `}` 

Ну а вобщем, с массивом char всё более менее нормально, только один ньюанс:
```c
char array[] = {'H', 'e', 'l', 'l', 'o'}; //размер такого массива равен 5
char array[] = "Hello"; // sizeof(arr) = 6
```

Потому что С автоматически ставит 0 в конце каждой строки, это на самом деле удобно, многие библиотечные функции ориентируются на 0, как на конец строки

## Двумерные массивы
Просто последовательно хранятся в памяти строка за строкой

И на самом деле, вот немного синтаксического сахара:

```c
char m[2][2] = {{1, 2}, {3, 4}};
# m[1][1] = m[2*1 + 1]; //4
```

### Выход за пределы массива
В С нет проверки на выход за пределы массива, такова цена скорости работы.
Компилятор не выведет никакой ошибки, если мы назначим значение за пределами массива

```c
int array[2] = {0, 1}
array[3] = 1; //ну ок
array[-1] = 1; //а вот потом попробуй узнай чего твоя прога не работает
```
