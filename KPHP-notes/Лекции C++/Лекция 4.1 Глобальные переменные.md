**Глобальная переменная** - переменная, область видимости которой неограничена одной функцией.

```c
int last_rnd = 0; //объявляем глобальную переменную, по умолчанию она равна нулю, но лучше это указать явно

void srand() {
	last_rnd = time(); //текущее время
}

int rand() {
	last_rnd = (last_rnd * 13 + 113) % 43;
	return last_rnd;
}

int main() {
	int a[10];
	srand();
	for(int i = 0; i < 10; i++) a[i] = rand();
}
```

Если что это пример как генерировать последовательность псевдо-случайных чисел в диапозоне от 0 до 42

## Статические переменные (static)
Зачем они нам? Допустим ты хочешь занять область памяти для глобальных переменных, чтобы при повторном вызове функция уже брала значения, которые она уже использовала. Такую штуку назвали статической переменной.
Для этого используются ключевою слово `static`

```c
void f() {
	static int call_count = 0; //инициализируется один раз
	...
	printf("Called times: %d", call_count);
	call_count++;
}

int main() {
	f(); f(); f();
}
```

То есть за пределами функции переменную  `call_count` не видно, но сама функция сначала инициализирует переменную в области памяти для глобальных переменных. А при повторном вызове видит, что `call_count` уже есть и работает с уже созданной ранее переменной.

## Переиспользовать одну переменную в нескольких файлах

Что если объявить переменную с одинаковым названием в разных файлах, а затем их слинковать?

```c
//1.cpp
int last_rnd = 0;
void srand() {
	last_rnd = time(); //текущее время
}
```

```c
//2.cpp
int last_rnd = 0;
int rand() {
	last_rnd = (lst_rnd * 13 + 113) % 43;
	return last_rnd;
}
```

При компиляции никакой ошибки конечно не будет, ведь комплируются файлы по отдельности, а вот уже линковщих не поймёт из какого именно файла берётся значение для глобальной переменной `last_rnd` 

**Так что так делать нельзя. А как можно?**
Можно использовать ключевое слово `extern` - оно сообщает компилятору, что где-то определена переменная с нужным названием и типом. На стадии линковки подставиться её адрес

Вот как делать правильно:
```c
//1.h
extern int last_rnd;
```

```c
//1.cpp
int last_rnd = 0; //выделение памяти
void srand() {
	last_rnd = time(); //текущее время
}
```

```c
//2.cpp

#include "1.h"

//extern -> выделение памяти происходит в другом месте 
//также знаем тип переменной
int rand() {
	last_rnd = (lst_rnd * 13 + 113) % 43;
	return last_rnd;
}
```

## Static. Как сделать так, чтобы переменная была видна только в пределах одного файла

Слово `static` имеет два разных смысла в зависимости от контекста.
```c
int a = 0; // Глобальная переменная (видна во всех файлах)
static int b = 0; // Глобальная переменная
// (видна только в этом файле)

void f() {
	static int c = 0; // Статическая переменная
	// (видна только в функции)
}
```

- К переменной `a` можно обращаться из других файлов при помощи extern.
- Переменная `b` не будет видна из других файлов даже если есть extern.
- Переменную `c` вообще не имеет смысла видеть в других файлах.

## Как сохраняются глобальные переменные

![[Pasted image 20221228170937.png]]

- В заголовке двоичного исполняемого файла `.elf` написано, сколько static variables ему требуетс
- Память выделяется “непрерывным куском” при загрузке программы. Освобождается — когда программа заканчивает работу.
- Выделение происходит быстро.


## Почему все хейтят глобальные переменные

1. Если ты пишешь новую библиотечную функцию, то не смей использовать глобальные переменные. Во-первых ты скорее всего назовёшь её size, ну или count и т.п. А потом увидишь, что в другой библиотеке, которую ты подключаешь есть переменная с тем же названием и будет конфилкт имён

2. Если кто-то читает твою программу впервые то глобальные переменные вводят в замешательство. Не понятно где они объявлены и где используются. Какой тип у используемой переменной. Как и где эта переменная меняется

3. Порядок инициализации переменных в разных файлов не определён в документации. Этот пример иногда собирается нормально, а иногда с ошибкой: 
```c
// a.cpp
int ten = 10; // Первый, потому что константа
int x = ten; // Второй или третий
int foo() { return x; }

// b.cpp
int y = foo(); // Второй или третий
```

***Короче, используй static, а глобальные переменные лучше не надо ))***
